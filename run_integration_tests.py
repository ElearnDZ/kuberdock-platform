import logging
import os
import sys
import threading
from contextlib import closing
from datetime import timedelta
from threading import Thread

import click
from colorama import Fore

from tests_integration.lib import multilogger
from tests_integration.lib.integration_test_runner import TestResultCollection, \
    discover_integration_tests, format_exception, write_junit_xml
from tests_integration.lib.integration_test_utils import get_test_full_name, \
    center_text_message
from tests_integration.lib.pipelines import pipelines as \
    registered_pipelines
from tests_integration.lib.pipelines_base import Pipeline

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

INTEGRATION_TESTS_PATH = 'tests_integration/'
JENKINS_GC_TIME_INTERVAL = 2  # hours
# Lock is needed for printing info thread-safely and it's done by two
# separate print calls
print_lock = threading.Lock()
test_results = TestResultCollection()
debug_messages = []


def print_msg(msg='', color=Fore.MAGENTA):
    with print_lock:
        print('{}{}{}'.format(color, msg, Fore.RESET))
        sys.stdout.flush()


def run_tests_in_a_pipeline(pipeline_name, tests, cluster_debug=False):
    """
    :param cluster_debug: if True cluster isn't destroyed on any test
        failure
    :param pipeline_name: pipeline name
    :param tests: list of callables
    """

    # Helper function to make code less verbose
    def pipe_log(msg, color=Fore.MAGENTA):
        print_msg('{} -> {}\n'.format(pipeline_name, msg), color)

    def prettify_exception(exc):
        return '{}: {}'.format(exc.__class__.__name__, str(exc))

    try:
        pipeline = Pipeline.from_name(pipeline_name)
        pipe_log('CREATING CLUSTER', Fore.MAGENTA)
        pipeline.create()
        pipe_log('CLUSTER CREATED', Fore.GREEN)
    except Exception as e:
        test_results.register_pipeline_error(pipeline_name, tests,
                                             prettify_exception(e))

        msg = format_exception(sys.exc_info())
        pipe_log('CLUSTER CREATION FAILED\n{}'.format(msg), Fore.RED)
        return

    for test in tests:
        test_name = get_test_full_name(test)
        pipe_log('{} -> STARTED'.format(test_name))

        try:
            pipeline.run_test(test)
            test_results.register_success(test, pipeline_name)

            pipe_log('{} -> PASSED'.format(test_name), Fore.GREEN)
        except:
            test_results.register_failure(test, pipeline_name)
            msg = format_exception(sys.exc_info())
            pipe_log('{} -> FAILED\n{}'.format(test_name, msg), Fore.RED)

    if cluster_debug and test_results.has_any_failures(pipeline_name):
        add_debug_info(pipeline)
    else:
        pipeline.destroy()

    print_msg(test_results.pipeline_test_summary(pipeline_name))


def add_debug_info(pipeline):
    """
    Save information about when cluster is going to be destroyed by Jenkins GC
    """
    if not pipeline.build_cluster:
        return
    master_ip = pipeline.cluster.get_host_ip('master')
    msg = 'Pipeline {} has failed tests, it remains alive until about ' \
          '{} so that you can debug it. Master IP: {}'
    destroy_time = pipeline.cluster.created_at + timedelta(
        hours=JENKINS_GC_TIME_INTERVAL)
    debug_messages.append(
        msg.format(pipeline.name, destroy_time.isoformat(' '), master_ip))


def start_test(pipeline, tests, cluster_debug):
    """
    Create a thread which creates a pipeline and starts executing tests in it
    :param pipeline: tuple (name, thread)
    :param tests: a list of callables
    :return: created Thread object
    """

    full_name = '{}_{}'.format(*pipeline)
    t = Thread(
        name=full_name, target=run_tests_in_a_pipeline,
        args=(full_name, tests, cluster_debug))
    t.start()
    return t


def get_pipeline_logs(multilog):
    """
    Prints logs generated by each pipeline
    :param multilog: logger handler instance
    """

    def _format_log(name, log):
        return center_text_message(name, color=Fore.MAGENTA) + '\n' + log

    entries = (
        _format_log(name, log)
        for name, log in multilog.grouped_by_thread.items()
        if test_results.has_any_failures(name)
    )

    msg = '\n' + '\n'.join(entries)

    return center_text_message(
        'PIPELINE DETAILED LOGS', fill_char='=', color=Fore.MAGENTA) + msg


def _print_logs(handler, live_log):
    # If live log was enabled all the logs were already printed
    if not live_log:
        print(get_pipeline_logs(handler))
    print(test_results.get_tests_report())
    if debug_messages:
        print(center_text_message('Debug messages'))
        print('\n'.join(debug_messages))


def _filter_test_by_name(name, pipelines):
    for pipe, tests in pipelines.items():
        for test in tests:
            if test.__name__ == name:
                return {pipe: [test]}

    raise click.BadArgumentUsage('Test "{}" was not found'.format(name))


def _filter_pipelines(pipelines):
    if not pipelines:
        return registered_pipelines

    return {k: v
        for k, v in registered_pipelines.items() if k[0] in pipelines}


def _verify_paths(ctx, param, items):
    bad_paths = [i for i in items if not os.path.exists(i)]
    if bad_paths:
        message = 'could not find following paths:\n{}'.format('\n'.join(
            bad_paths))
        raise click.BadArgumentUsage(message)
    return items


def _verify_pipelines(ctx, param, items):
    if not items:
        return []
    return items.split(',')


@click.command(context_settings={'help_option_names': ['-h', '--help']})
@click.argument('paths', nargs=-1, callback=_verify_paths)
@click.option('--pipelines', callback=_verify_pipelines,
              help='Comma separated pipeline names to use')
@click.option('--live-log', is_flag=True,
              help='Instantly print test logs to the console')
@click.option('--all-tests', is_flag=True, help='Grab all available tests')
@click.option('--cluster-debug', is_flag=True, default=False,
              help='Enable debug mode. Currently this does not destroy a '
                   'cluster if any of its tests failed.')
@click.option('--junit-xml', type=click.File(mode='w'))
@click.option('--test', type=str, help='A name of a test to run')
def main(
        paths, pipelines, live_log, all_tests, cluster_debug, junit_xml, test):
    if bool(all_tests) == bool(test):
        raise click.BadOptionUsage(
            'You should specify either --test NAME or --all-tests')

    with closing(multilogger.init_handler(logger, live_log)) as multilog:
        discovered = discover_integration_tests(
            paths or [INTEGRATION_TESTS_PATH])

        message = 'Discovered tests in:\n{}\n'.format('\n'.join(discovered))
        print_msg(message)

        requested_pipelines = _filter_pipelines(pipelines)

        if test:
            requested_pipelines = _filter_test_by_name(
                test, requested_pipelines)

        if not os.environ.get('BUILD_CLUSTER') and len(
                requested_pipelines) > 1:
            sys.exit('Can not run multiple pipelines with unset BUILD_CLUSTER')

        threads = [start_test(pipe, tests, cluster_debug)
            for pipe, tests in requested_pipelines.items()]

        for t in threads:
            t.join()

        _print_logs(multilog, live_log)

        if junit_xml:
            write_junit_xml(junit_xml, test_results)

        if test_results.has_any_failures():
            sys.exit(1)


if __name__ == "__main__":
    main()
