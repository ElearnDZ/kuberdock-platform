import logging
import os
import random
import sys
import threading
import time
from contextlib import closing
from threading import Thread

import click
from colorama import Fore

from tests_integration.lib import multilogger
from tests_integration.lib.integration_test_runner import TestResultCollection, \
    discover_integration_tests, format_exception
from tests_integration.lib.integration_test_utils import get_test_full_name, \
    center_text_message
from tests_integration.lib.pipelines import pipelines as \
    registered_pipelines, Pipeline

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)

CLUSTER_CREATION_MAX_DELAY = 30
INTEGRATION_TESTS_PATH = 'tests_integration/'
# Lock is needed for printing info thread-safely and it's done by two
# separate print calls
print_lock = threading.Lock()
test_results = TestResultCollection()


def print_msg(msg='', color=Fore.MAGENTA):
    with print_lock:
        print('{}{}{}'.format(color, msg, Fore.RESET))
        sys.stdout.flush()


def run_tests_in_a_pipeline(name, tests):
    """
    :param name: pipeline name
    :param tests: list of callables
    """

    # Helper function to make code less verbose
    def pipe_log(msg, color=Fore.MAGENTA):
        print_msg('{} -> {}\n'.format(name, msg), color)

    # Prevent Nebula from being flooded by vm-create requests (AC-3914)
    delay = random.randint(0, CLUSTER_CREATION_MAX_DELAY)
    pipe_log('CREATING CLUSTER (delay {} seconds)'.format(delay), Fore.MAGENTA)
    time.sleep(delay)

    try:
        pipeline = Pipeline.from_name(name)
        pipeline.create()
        pipe_log('CLUSTER CREATED', Fore.GREEN)
    except:
        test_results.register_pipeline_error(name, tests)
        msg = format_exception(sys.exc_info())
        pipe_log('CLUSTER CREATION FAILED\n{}'.format(msg), Fore.RED)
        return

    for test in tests:
        test_name = get_test_full_name(test)
        pipe_log('{} -> STARTED'.format(test_name))

        try:
            pipeline.run_test(test)
            test_results.register_success(test_name, name)

            pipe_log('{} -> PASSED'.format(test_name), Fore.GREEN)
        except:
            test_results.register_failure(test_name, name)
            msg = format_exception(sys.exc_info())
            pipe_log('{} -> FAILED\n{}'.format(test_name, msg), Fore.RED)

    pipeline.destroy()
    print_msg(test_results.pipeline_test_summary(name))


def start_test(pipeline, tests):
    """
    Create a thread which creates a pipeline and starts executing tests in it
    :param pipeline: tuple (name, thread)
    :param tests: a list of callables
    :return: created Thread object
    """

    full_name = '{}_{}'.format(*pipeline)
    t = Thread(
        name=full_name, target=run_tests_in_a_pipeline,
        args=(full_name, tests))
    t.start()
    return t


def get_pipeline_logs(handler):
    """
    Prints logs generated by each pipeline
    :param handler: logger handler instance
    """

    def _format_log(name, fp):
        fp.seek(0)
        arr = [
            center_text_message(name, color=Fore.MAGENTA),
            fp.read(),
        ]
        return '\n'.join(arr)

    entries = (_format_log(name, fp) for name, fp in handler.files.items())
    msg = '\n' + '\n'.join(entries)

    return center_text_message(
        'PIPELINE DETAILED LOGS', fill_char='=', color=Fore.MAGENTA) + msg


def _verify_paths(ctx, param, items):
    bad_paths = [i for i in items if not os.path.exists(i)]
    if bad_paths:
        message = 'could not find following paths:\n{}'.format('\n'.join(
            bad_paths))
        raise click.BadArgumentUsage(message)
    return items


def _verify_pipelines(ctx, param, items):
    if not items:
        return []
    return items.split(',')


@click.command()
@click.argument('paths', nargs=-1, callback=_verify_paths)
@click.option('--pipelines', callback=_verify_pipelines)
@click.option('--live-log', is_flag=True)
def main(paths, pipelines, live_log):
    with closing(multilogger.init_handler(logger, live_log)) as handler:
        discovered = discover_integration_tests(
            paths or [INTEGRATION_TESTS_PATH])

        message = 'Discovered tests in:\n{}\n'.format('\n'.join(discovered))
        print_msg(message)

        if not pipelines:
            requested = registered_pipelines
        else:
            requested = {
                k: v
                for k, v in registered_pipelines.items() if k[0] in pipelines}
        threads = [
            start_test(pipe, tests) for pipe, tests in requested.items()
            ]

        for t in threads:
            t.join()

        # If live log was enabled all the logs were already printed
        if not live_log:
            print(get_pipeline_logs(handler))

        print(test_results.get_tests_report())

        if test_results.has_any_failures():
            sys.exit(1)


if __name__ == "__main__":
    main()
